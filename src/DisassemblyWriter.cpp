// ==================================
//             SIDwinder
//
//  Raistlin / Genesis Project (G*P)
// ==================================
#include "DisassemblyWriter.h"
#include "SIDLoader.h"
#include "cpu6510.h"

#include <algorithm>
#include <iostream>
#include <queue>
#include <set>
#include <functional>

namespace sidwinder {

    /**
     * @brief Constructor for DisassemblyWriter
     *
     * Initializes the disassembly writer with references to the CPU, SID loader,
     * memory analyzer, label generator, and code formatter.
     *
     * @param cpu Reference to the CPU
     * @param sid Reference to the SID loader
     * @param analyzer Reference to the memory analyzer
     * @param labelGenerator Reference to the label generator
     * @param formatter Reference to the code formatter
     */
    DisassemblyWriter::DisassemblyWriter(
        const CPU6510& cpu,
        const SIDLoader& sid,
        const MemoryAnalyzer& analyzer,
        const LabelGenerator& labelGenerator,
        const CodeFormatter& formatter)
        : cpu_(cpu),
        sid_(sid),
        analyzer_(analyzer),
        labelGenerator_(labelGenerator),
        formatter_(formatter) {
        pointerDetector_ = std::make_unique<PointerBasedSelfModificationDetector>();
    }

    /**
     * @brief Generate an assembly file
     *
     * Creates a complete assembly language file for the disassembled SID,
     * including header comments, constants, and code.
     *
     * @param filename Output filename
     * @param sidLoad New SID load address
     * @param sidInit New SID init address
     * @param sidPlay New SID play address
     */
    void DisassemblyWriter::generateAsmFile(
        const std::string& filename,
        u16 sidLoad,
        u16 sidInit,
        u16 sidPlay,
        bool removeCIAWrites) {

        // Open the output file
        std::ofstream file(filename);
        if (!file) {
            util::Logger::error("Failed to open output file: " + filename);
            return;
        }

        // Write file header
        file << "//; ------------------------------------------\n";
        file << "//; Generated by " << SIDwinder_VERSION << "\n";
        file << "//; \n";
        file << "//; Name: " << sid_.getHeader().name << "\n";
        file << "//; Author: " << sid_.getHeader().author << "\n";
        file << "//; Copyright: " << sid_.getHeader().copyright << "\n";
        file << "//; ------------------------------------------\n\n";

        // Output addresses as constants
        file << ".const SIDLoad = $" << util::wordToHex(sidLoad) << "\n";

        // Output hardware registers as constants
        outputHardwareConstants(file);

        // Output zero page defines
        emitZPDefines(file);

        // Disassemble to file
        disassembleToFile(file, removeCIAWrites);

        file.close();
    }

    /**
     * @brief Add an indirect memory access
     *
     * Records information about an indirect memory access for later analysis.
     * Enhanced to collect more detailed information about pointer usage.
     *
     * @param pc Program counter
     * @param zpAddr Zero page address
     * @param targetAddr Target address
     */
    void DisassemblyWriter::addIndirectAccess(u16 pc, u8 zpAddr, u16 targetAddr) {
        // Get the sources of the ZP variables
        const auto& lowSource = cpu_.getWriteSourceInfo(zpAddr);
        const auto& highSource = cpu_.getWriteSourceInfo(zpAddr + 1);

        // Get the last instructions that wrote to these ZP addresses
        u16 lastWriteLow = cpu_.getLastWriteTo(zpAddr);
        u16 lastWriteHigh = cpu_.getLastWriteTo(zpAddr + 1);

        // Look for an existing record for this ZP address
        IndirectAccessInfo* existingInfo = nullptr;
        for (auto& existing : indirectAccesses_) {
            if (existing.zpAddr == zpAddr &&
                existing.sourceLowAddress == lowSource.address &&
                existing.sourceHighAddress == highSource.address) {
                existingInfo = &existing;
                break;
            }
        }

        // If not found, create a new entry
        if (!existingInfo) {
            IndirectAccessInfo info;
            info.instructionAddress = pc;
            info.zpAddr = zpAddr;
            info.lastWriteLow = lastWriteLow;
            info.lastWriteHigh = lastWriteHigh;

            // Capture source addresses when available
            if (lowSource.type == RegisterSourceInfo::SourceType::Memory) {
                info.sourceLowAddress = lowSource.address;
            }

            if (highSource.type == RegisterSourceInfo::SourceType::Memory) {
                info.sourceHighAddress = highSource.address;
            }

            // Add this target address
            info.targetAddresses.push_back(targetAddr);

            // Add to the collection
            indirectAccesses_.push_back(info);
        }
        else {
            // Add this target address to the existing entry if not already present
            if (std::find(existingInfo->targetAddresses.begin(),
                existingInfo->targetAddresses.end(),
                targetAddr) == existingInfo->targetAddresses.end()) {
                existingInfo->targetAddresses.push_back(targetAddr);
            }
        }
    }

    /**
     * @brief Process all recorded indirect accesses
     *
     * Analyzes indirect access patterns to identify address references
     * and pointer tables. Updated to use the new RelocationTable approach.
     */
    void DisassemblyWriter::processIndirectAccesses() {
        util::Logger::info("=== Processing Indirect Accesses and Self-Modifying Patterns ===");

        if (indirectAccesses_.empty() && selfModifyingPatterns_.empty()) {
            util::Logger::info("No indirect accesses or self-modifying patterns to process");
            return;
        }

        // Get memory data flow from CPU
        const auto& dataFlow = cpu_.getMemoryDataFlow();

        // Clear any existing entries in relocTable_
        relocTable_.clear();

        // Process indirect accesses (existing code)
        util::Logger::info("Processing " + std::to_string(indirectAccesses_.size()) + " indirect accesses");
        for (const auto& access : indirectAccesses_) {
            if (!access.targetAddresses.empty()) {
                u16 targetAddr = access.targetAddresses[0];

                if (access.sourceLowAddress != 0) {
                    relocTable_.addEntry(access.sourceLowAddress, targetAddr, RelocationEntry::Type::Low);
                    const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(access.sourceLowAddress);
                    processRelocationChain(dataFlow, relocTable_, access.sourceLowAddress, targetAddr, RelocationEntry::Type::Low);

                    util::Logger::info("Added indirect low byte relocation: $" +
                        util::wordToHex(access.sourceLowAddress) + " -> <(" +
                        labelGenerator_.formatAddress(targetAddr) + ")");
                }

                if (access.sourceHighAddress != 0) {
                    relocTable_.addEntry(access.sourceHighAddress, targetAddr, RelocationEntry::Type::High);
                    const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(access.sourceHighAddress);
                    processRelocationChain(dataFlow, relocTable_, access.sourceHighAddress, targetAddr, RelocationEntry::Type::High);

                    util::Logger::info("Added indirect high byte relocation: $" +
                        util::wordToHex(access.sourceHighAddress) + " -> >(" +
                        labelGenerator_.formatAddress(targetAddr) + ")");
                }
            }
        }

        // Process self-modifying code patterns
        util::Logger::info("Processing self-modifying code patterns for " +
            std::to_string(selfModifyingPatterns_.size()) + " instructions");

        for (const auto& [instrAddr, patterns] : selfModifyingPatterns_) {
            util::Logger::info("Processing patterns for instruction at $" + util::wordToHex(instrAddr));

            for (size_t i = 0; i < patterns.size(); i++) {
                const auto& pattern = patterns[i];
                util::Logger::info("  Processing pattern " + std::to_string(i));

                // For self-modifying patterns, we only handle high byte modifications
                // since this code assumes page-aligned relocations (low byte stays the same)

                // Handle high byte modifications
                if (pattern.hasHighByte && pattern.highByteIsImmediate) {
                    // This came from an immediate operand - create relocation for the operand
                    u16 operandAddr = pattern.highByteInstrPC + 1; // +1 to get to the operand byte

                    // For page-aligned relocation, we need to determine what address this high byte refers to
                    // We can look at the JSR instruction being modified to get the full target address
                    u16 jsrTarget = cpu_.getMemory()[instrAddr + 1] | (cpu_.getMemory()[instrAddr + 2] << 8);

                    util::Logger::info("    JSR instruction being modified has current target: $" +
                        util::wordToHex(jsrTarget));

                    // The target address for relocation is the address this high byte points to
                    // We'll use the current JSR target as our reference
                    u16 targetAddr = jsrTarget;

                    relocTable_.addEntry(operandAddr, targetAddr, RelocationEntry::Type::High);
                    const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(operandAddr);

                    util::Logger::info("    Added immediate high byte relocation: $" +
                        util::wordToHex(operandAddr) + " -> >(" +
                        labelGenerator_.formatAddress(targetAddr) + ")");

                }
                else if (pattern.hasHighByte && pattern.highByteSource != 0) {
                    // This came from memory - existing logic  
                    u16 jsrTarget = cpu_.getMemory()[instrAddr + 1] | (cpu_.getMemory()[instrAddr + 2] << 8);

                    relocTable_.addEntry(pattern.highByteSource, jsrTarget, RelocationEntry::Type::High);
                    const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(pattern.highByteSource);
                    processRelocationChain(dataFlow, relocTable_, pattern.highByteSource, jsrTarget, RelocationEntry::Type::High);

                    util::Logger::info("    Added memory high byte relocation: $" +
                        util::wordToHex(pattern.highByteSource) + " -> >(" +
                        labelGenerator_.formatAddress(jsrTarget) + ")");
                }

                // For low byte modifications (rare in page-aligned self-modifying code)
                if (pattern.hasLowByte && pattern.lowByteIsImmediate) {
                    u16 operandAddr = pattern.lowByteInstrPC + 1;
                    u16 jsrTarget = cpu_.getMemory()[instrAddr + 1] | (cpu_.getMemory()[instrAddr + 2] << 8);

                    relocTable_.addEntry(operandAddr, jsrTarget, RelocationEntry::Type::Low);
                    const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(operandAddr);

                    util::Logger::info("    Added immediate low byte relocation: $" +
                        util::wordToHex(operandAddr) + " -> <(" +
                        labelGenerator_.formatAddress(jsrTarget) + ")");

                }
                else if (pattern.hasLowByte && pattern.lowByteSource != 0) {
                    u16 jsrTarget = cpu_.getMemory()[instrAddr + 1] | (cpu_.getMemory()[instrAddr + 2] << 8);

                    relocTable_.addEntry(pattern.lowByteSource, jsrTarget, RelocationEntry::Type::Low);
                    const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(pattern.lowByteSource);
                    processRelocationChain(dataFlow, relocTable_, pattern.lowByteSource, jsrTarget, RelocationEntry::Type::Low);

                    util::Logger::info("    Added memory low byte relocation: $" +
                        util::wordToHex(pattern.lowByteSource) + " -> <(" +
                        labelGenerator_.formatAddress(jsrTarget) + ")");
                }
            }
        }

        util::Logger::info("Total relocation entries created: " +
            std::to_string(relocTable_.getAllEntries().size()));
    }

    void DisassemblyWriter::onMemoryFlow(u16 pc, char reg, u16 sourceAddr, u8 value, bool isIndexed) {

        // Store the source information for this register
        registerSources_[reg] = { sourceAddr, value, isIndexed };
        const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(sourceAddr);
    }

    void DisassemblyWriter::onComparison(u16 pc, char reg, u8 compareValue, u16 sourceAddr, bool isMemorySource) {
        if (pointerDetector_) {
            ComparisonRecord record;
            record.pc = pc;
            record.reg = reg;
            record.compareValue = compareValue;
            record.sourceAddr = sourceAddr;
            record.isMemorySource = isMemorySource;
            record.nextPC = pc + 2; // Most comparisons are 2 bytes, adjust as needed

            pointerDetector_->recordComparison(record);
        }
    }

    void DisassemblyWriter::processRelocationChain(
        const MemoryDataFlow& dataFlow,
        RelocationTable& relocTable,
        u16 addr,
        u16 targetAddr,
        RelocationEntry::Type relocType) {

        // Add entry with the EXACT target address as received - no adjustments
        relocTable.addEntry(addr, targetAddr, relocType);

        // Mark this source address for potential subdivision
        const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(addr);

        // Find any other memory locations that write to this address
        auto it = dataFlow.memoryWriteSources.find(addr);
        if (it != dataFlow.memoryWriteSources.end()) {
            // Process each source address that writes to this address
            for (u16 newAddr : it->second) {
                // Skip self-references to avoid infinite recursion
                if (newAddr != addr) {
                    // Use SAME target address for all chain entries to ensure consistency
                    processRelocationChain(dataFlow, relocTable, newAddr, targetAddr, relocType);
                }
            }
        }
    }

    /**
     * @brief Output hardware constants to the assembly file
     *
     * Identifies hardware components (like SID chips) that are accessed
     * in the code and generates appropriate constant definitions.
     *
     * @param file Output stream
     */
    void DisassemblyWriter::outputHardwareConstants(std::ofstream& file) {
        // Find all accessed hardware components

        // SID detection
        std::set<u16> sidBases;
        for (u16 addr = 0xD400; addr <= 0xD7FF; addr++) {
            if (analyzer_.getMemoryType(addr) & (MemoryType::Accessed)) {
                u16 base = addr & 0xFFE0; // Align to 32 bytes for SID
                sidBases.insert(base);
            }
        }

        // Ensure at least one SID is always present
        if (sidBases.empty()) {
            sidBases.insert(0xD400);
        }

        // Register SID bases
        int sidIndex = 0;
        for (u16 base : sidBases) {
            const std::string name = "SID" + std::to_string(sidIndex);

            // Register with label generator
            const_cast<LabelGenerator&>(labelGenerator_).addHardwareBase(
                HardwareType::SID, base, sidIndex, name);

            // Output to assembly file
            file << ".const " << name << " = $" << util::wordToHex(base) << "\n";

            sidIndex++;
        }

        // Future hardware component detection can be added here:
        // VIC-II detection (0xD000-0xD3FF)
        // CIA detection (0xDC00-0xDCFF for CIA1, 0xDD00-0xDDFF for CIA2)
        // etc.

        file << "\n";
    }

    /**
     * @brief Output zero page definitions to the assembly file
     *
     * Identifies zero page variables used by the code and generates
     * appropriate constant definitions.
     *
     * @param file Output stream
     */
    void DisassemblyWriter::emitZPDefines(std::ofstream& file) {
        // Collect all used zero page addresses
        std::set<u8> usedZP;
        for (u16 addr = 0x0000; addr <= 0x00FF; ++addr) {
            if (analyzer_.getMemoryType(addr) & MemoryType::Accessed) {
                usedZP.insert(static_cast<u8>(addr));
            }
        }

        std::set<u8> indexedZP;
        findIndexedZeroPageAccesses(indexedZP);

        // Merge the sets
        usedZP.insert(indexedZP.begin(), indexedZP.end());

        if (usedZP.empty()) {
            return;
        }

        // Convert to vector for sorting
        std::vector<u8> zpList(usedZP.begin(), usedZP.end());
        std::sort(zpList.begin(), zpList.end());

        // Calculate ZP base
        u8 zpBase = 0xFF - static_cast<u8>(zpList.size()) + 1;

        // Output ZP defines
        file << ".const ZP_BASE = $" << util::byteToHex(zpBase) << "\n";
        for (size_t i = 0; i < zpList.size(); ++i) {
            std::string varName = "ZP_" + std::to_string(i);
            file << ".const " << varName << " = ZP_BASE + " << i << " // $" << util::byteToHex(zpList[i]) << "\n";

            // Add to label generator
            const_cast<LabelGenerator&>(labelGenerator_).addZeroPageVar(zpList[i], varName);
        }

        file << "\n";
    }

    // Helper method to find indexed zero page accesses
    void DisassemblyWriter::findIndexedZeroPageAccesses(std::set<u8>& indexedZP) {
        const u16 sidStart = sid_.getLoadAddress();
        const u16 sidEnd = sidStart + sid_.getDataSize();

        // Scan through all code for indexed zero page instructions
        for (u16 pc = sidStart; pc < sidEnd; ) {
            if (!(analyzer_.getMemoryType(pc) & MemoryType::Code)) {
                ++pc;
                continue;
            }

            const u8 opcode = cpu_.getMemory()[pc];
            const auto mode = cpu_.getAddressingMode(opcode);
            const int size = cpu_.getInstructionSize(opcode);

            // Check for zero page indexed addressing modes
            if (mode == AddressingMode::ZeroPageX || mode == AddressingMode::ZeroPageY) {
                const u8 baseAddr = cpu_.getMemory()[pc + 1];

                // Get the range of indices used with this instruction
                const auto [minIndex, maxIndex] = cpu_.getIndexRange(pc);

                // Add all addresses in the range
                for (int i = minIndex; i <= maxIndex; ++i) {
                    u8 effectiveAddr = (baseAddr + i) & 0xFF; // Zero page wrapping
                    indexedZP.insert(effectiveAddr);
                }

                // If no index range recorded, assume at least the base address
                if (minIndex == 0 && maxIndex == 0) {
                    indexedZP.insert(baseAddr);
                }
            }

            if (mode == AddressingMode::AbsoluteY || mode == AddressingMode::AbsoluteX) {
                const u16 baseAddr = cpu_.getMemory()[pc + 1] | (cpu_.getMemory()[pc + 2] << 8);

                // Check if this absolute address is actually in zero page
                if (baseAddr <= 0xFF) {
                    const auto [minIndex, maxIndex] = cpu_.getIndexRange(pc);

                    // Add all addresses in the range
                    for (int i = minIndex; i <= maxIndex; ++i) {
                        u8 effectiveAddr = (baseAddr + i) & 0xFF; // Zero page wrapping
                        indexedZP.insert(effectiveAddr);
                    }
                }
            }

            pc += size;
        }
    }

    /**
     * @brief Disassemble to the output file
     *
     * Performs the actual disassembly writing to the file, handling code,
     * data, and labels appropriately.
     *
     * @param file Output stream
     */
    void DisassemblyWriter::disassembleToFile(std::ofstream& file, bool removeCIAWrites) {

        formatter_.setCIAWriteRemoval(removeCIAWrites);

        u16 pc = sid_.getLoadAddress();
        file << "\n* = SIDLoad\n\n";

         const u16 sidEnd = sid_.getLoadAddress() + sid_.getDataSize();

        while (pc < sidEnd) {
            // Check if we need to output a label
            const std::string label = labelGenerator_.getLabel(pc);
            if (!label.empty() && (analyzer_.getMemoryType(pc) & MemoryType::Code)) {
                file << label << ":\n";
            }

            // Check if this is code or data
            if (analyzer_.getMemoryType(pc) & MemoryType::Code) {
                const u16 startPc = pc;
                const std::string line = formatter_.formatInstruction(pc);

                file << util::padToColumn(line, 96);
                file << " //; $" << util::wordToHex(startPc) << " - "
                    << util::wordToHex(pc - 1) << "\n";
            }
            else if (analyzer_.getMemoryType(pc) & MemoryType::Data) {
                // Format data bytes
                formatter_.formatDataBytes(
                    file,
                    pc,
                    sid_.getOriginalMemory(),
                    sid_.getOriginalMemoryBase(),
                    sidEnd,
                    relocTable_.getAllEntries(),
                    analyzer_.getMemoryTypes());
            }
            else {
                // Unknown memory type, just increment PC
                ++pc;
            }
        }
    }

    void DisassemblyWriter::analyzeWritesForSelfModification() {
        util::Logger::info("=== Analyzing " + std::to_string(allWrites_.size()) +
            " writes for self-modification ===");

        int selfModifyingCount = 0;
        std::set<std::tuple<u16, int, u8>> processedWrites; // instrAddr, offset, value

        for (const auto& write : allWrites_) {
            if (analyzer_.getMemoryType(write.addr) & MemoryType::Code) {
                u16 instrStart = analyzer_.findInstructionStartCovering(write.addr);
                if (instrStart != write.addr) {
                    int offset = write.addr - instrStart;

                    // Create unique key for this write
                    auto writeKey = std::make_tuple(instrStart, offset, write.value);

                    // Skip if we've already processed this exact write
                    if (processedWrites.find(writeKey) != processedWrites.end()) {
                        continue;
                    }
                    processedWrites.insert(writeKey);

                    // Log first few self-modifying writes
                    if (selfModifyingCount < 10) {
                        util::Logger::info("Self-modifying write found: $" +
                            util::wordToHex(write.addr) + " (instr $" +
                            util::wordToHex(instrStart) + " +" + std::to_string(offset) +
                            ") = $" + util::byteToHex(write.value));

                        std::string sourceTypeStr;
                        if (write.sourceInfo.type == RegisterSourceInfo::SourceType::Memory) {
                            sourceTypeStr = "Memory";
                        }
                        else if (write.sourceInfo.type == RegisterSourceInfo::SourceType::Immediate) {
                            sourceTypeStr = "Immediate";
                        }
                        else {
                            sourceTypeStr = "Unknown";
                        }
                        util::Logger::info("  Source: " + sourceTypeStr +
                            " addr=$" + util::wordToHex(write.sourceInfo.address) +
                            " value=$" + util::byteToHex(write.sourceInfo.value));
                    }
                    selfModifyingCount++;

                    // Find or create a pattern for this specific modification
                    auto& patterns = selfModifyingPatterns_[instrStart];
                    SelfModifyingPattern* currentPattern = nullptr;

                    // Look for an existing pattern we can update
                    for (auto& pattern : patterns) {
                        // For offset 1 (low byte), look for pattern missing low byte or with same low byte
                        if (offset == 1) {
                            if (!pattern.hasLowByte ||
                                (pattern.hasLowByte && pattern.lowByte == write.value)) {
                                currentPattern = &pattern;
                                break;
                            }
                        }
                        // For offset 2 (high byte), look for pattern missing high byte or with same high byte
                        else if (offset == 2) {
                            if (!pattern.hasHighByte ||
                                (pattern.hasHighByte && pattern.highByte == write.value)) {
                                currentPattern = &pattern;
                                break;
                            }
                        }
                    }

                    // If no suitable pattern found, create a new one
                    if (!currentPattern) {
                        patterns.push_back(SelfModifyingPattern{});
                        currentPattern = &patterns.back();
                    }

                    // Update the pattern based on source type
                    if (write.sourceInfo.type == RegisterSourceInfo::SourceType::Immediate) {
                        // This came from an immediate operand (like LDA #$21)
                        if (offset == 1) {
                            currentPattern->lowByte = write.value;
                            currentPattern->hasLowByte = true;
                            currentPattern->lowByteIsImmediate = true;
                            currentPattern->lowByteInstrPC = write.sourceInfo.address;
                        }
                        else if (offset == 2) {
                            currentPattern->highByte = write.value;
                            currentPattern->hasHighByte = true;
                            currentPattern->highByteIsImmediate = true;
                            currentPattern->highByteInstrPC = write.sourceInfo.address;
                        }
                    }
                    else if (write.sourceInfo.type == RegisterSourceInfo::SourceType::Memory) {
                        // This came from memory
                        if (offset == 1) {
                            currentPattern->lowByteSource = write.sourceInfo.address;
                            currentPattern->lowByte = write.value;
                            currentPattern->hasLowByte = true;
                            currentPattern->lowByteIsImmediate = false;
                        }
                        else if (offset == 2) {
                            currentPattern->highByteSource = write.sourceInfo.address;
                            currentPattern->highByte = write.value;
                            currentPattern->hasHighByte = true;
                            currentPattern->highByteIsImmediate = false;
                        }
                    }

                    // Also check register flow for additional context
                    for (const auto& [reg, flow] : registerSources_) {
                        if (flow.value == write.value) {
                            // If we have memory source info, prefer that over register flow
                            if (!currentPattern->lowByteIsImmediate && offset == 1 &&
                                currentPattern->lowByteSource == 0 && flow.sourceAddr != 0) {
                                currentPattern->lowByteSource = flow.sourceAddr;
                            }
                            if (!currentPattern->highByteIsImmediate && offset == 2 &&
                                currentPattern->highByteSource == 0 && flow.sourceAddr != 0) {
                                currentPattern->highByteSource = flow.sourceAddr;
                            }
                            break;
                        }
                    }
                }
            }
        }

        util::Logger::info("Found " + std::to_string(selfModifyingCount) +
            " unique self-modifying writes");

        // Count and report patterns (with reasonable limits)
        size_t totalPatterns = 0;
        for (const auto& [addr, patterns] : selfModifyingPatterns_) {
            totalPatterns += patterns.size();

            // Log details only for first few instructions
            if (totalPatterns <= 5) {
                util::Logger::info("Instruction $" + util::wordToHex(addr) +
                    " has " + std::to_string(patterns.size()) + " pattern(s)");
            }
        }

        if (totalPatterns > 100) {
            util::Logger::warning("Created " + std::to_string(totalPatterns) +
                " patterns - this seems excessive, there may be a logic issue");
        }
        else {
            util::Logger::info("Created " + std::to_string(totalPatterns) + " total patterns");
        }
    }

    // Add this debug method to DisassemblyWriter class
    void DisassemblyWriter::debugSelfModifyingCode() {
        util::Logger::info("=== DEBUG: Self-Modifying Code Analysis ===");

        // First, let's see what register sources we have (current state only)
        util::Logger::info("Current register sources:");
        for (const auto& [reg, flow] : registerSources_) {
            util::Logger::info("  Register " + std::string(1, reg) +
                " = $" + util::byteToHex(flow.value) +
                " from $" + util::wordToHex(flow.sourceAddr) +
                (flow.isIndexed ? " (indexed)" : " (direct)"));
        }

        // Then let's examine UNIQUE writes to self-modifying instructions
        util::Logger::info("Examining UNIQUE writes to self-modifying instructions:");
        std::set<std::pair<u16, u8>> uniqueWrites; // addr, value pairs

        for (const auto& write : allWrites_) {
            if (analyzer_.getMemoryType(write.addr) & MemoryType::Code) {
                u16 instrStart = analyzer_.findInstructionStartCovering(write.addr);
                if (instrStart != write.addr) {
                    // Only log if we haven't seen this addr,value combination before
                    auto writeKey = std::make_pair(write.addr, write.value);
                    if (uniqueWrites.find(writeKey) == uniqueWrites.end()) {
                        uniqueWrites.insert(writeKey);

                        int offset = write.addr - instrStart;

                        util::Logger::info("Self-modifying write: $" +
                            util::wordToHex(write.addr) + " = $" + util::byteToHex(write.value));
                        util::Logger::info("  Instruction start: $" + util::wordToHex(instrStart) +
                            " + " + std::to_string(offset));
                        std::string sourceTypeStr;
                        if (write.sourceInfo.type == RegisterSourceInfo::SourceType::Memory) {
                            sourceTypeStr = "Memory";
                        }
                        else if (write.sourceInfo.type == RegisterSourceInfo::SourceType::Immediate) {
                            sourceTypeStr = "Immediate";
                        }
                        else {
                            sourceTypeStr = "Unknown";
                        }
                        util::Logger::info("  Source type: " + sourceTypeStr);
                        util::Logger::info("  Source address: $" + util::wordToHex(write.sourceInfo.address));
                        util::Logger::info("  Source value: $" + util::byteToHex(write.sourceInfo.value));
                        util::Logger::info("");

                        // Only show first 10 unique writes to avoid spam
                        if (uniqueWrites.size() >= 10) {
                            util::Logger::info("  ... (truncated after 10 unique writes)");
                            break;
                        }
                    }
                }
            }
        }

        // Finally, show the patterns we detected
        util::Logger::info("Detected self-modifying patterns:");
        for (const auto& [instrAddr, patterns] : selfModifyingPatterns_) {
            util::Logger::info("Instruction at $" + util::wordToHex(instrAddr) + ":");
            for (size_t i = 0; i < patterns.size(); i++) {
                const auto& pattern = patterns[i];
                util::Logger::info("  Pattern " + std::to_string(i) + ":");

                if (pattern.hasLowByte) {
                    util::Logger::info("    Low byte: $" + util::byteToHex(pattern.lowByte) +
                        (pattern.lowByteIsImmediate ?
                            " (immediate from PC $" + util::wordToHex(pattern.lowByteInstrPC) + ")" :
                            " (memory from $" + util::wordToHex(pattern.lowByteSource) + ")"));
                }

                if (pattern.hasHighByte) {
                    util::Logger::info("    High byte: $" + util::byteToHex(pattern.highByte) +
                        (pattern.highByteIsImmediate ?
                            " (immediate from PC $" + util::wordToHex(pattern.highByteInstrPC) + ")" :
                            " (memory from $" + util::wordToHex(pattern.highByteSource) + ")"));
                }

                if (pattern.hasLowByte && pattern.hasHighByte) {
                    u16 targetAddr = pattern.lowByte | (pattern.highByte << 8);
                    util::Logger::info("    Target address: $" + util::wordToHex(targetAddr));
                }
            }
        }
    }

    // Also, let's examine what instructions are being executed
    void DisassemblyWriter::debugInstructionAtAddress(u16 addr) {
        if (addr < cpu_.getMemory().size()) {
            u8 opcode = cpu_.getMemory()[addr];
            std::string mnemonic = std::string(cpu_.getMnemonic(opcode));
            AddressingMode mode = cpu_.getAddressingMode(opcode);
            int size = cpu_.getInstructionSize(opcode);

            util::Logger::info("Instruction at $" + util::wordToHex(addr) + ": " +
                mnemonic + " (opcode $" + util::byteToHex(opcode) +
                ", size " + std::to_string(size) + ")");

            if (size > 1) {
                util::Logger::info("  Operand bytes:");
                for (int i = 1; i < size; i++) {
                    if (addr + i < cpu_.getMemory().size()) {
                        util::Logger::info("    +" + std::to_string(i) + ": $" +
                            util::byteToHex(cpu_.getMemory()[addr + i]));
                    }
                }
            }
        }
    }

} // namespace sidwinder