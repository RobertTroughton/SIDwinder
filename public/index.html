<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIDwinder Web - C64 SID Music Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

            .header h1 {
                font-size: 2.5em;
                margin-bottom: 10px;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            }

            .header p {
                font-size: 1.1em;
                opacity: 0.9;
            }

        .main-content {
            padding: 40px;
        }

        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(102, 126, 234, 0.05);
        }

            .upload-section:hover {
                border-color: #764ba2;
                background: rgba(102, 126, 234, 0.1);
                transform: translateY(-2px);
            }

            .upload-section.dragover {
                background: rgba(102, 126, 234, 0.2);
                border-color: #764ba2;
            }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .upload-text {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 10px;
        }

        .upload-subtext {
            color: #666;
            font-size: 0.9em;
        }

        #fileInput {
            display: none;
        }

        .controls-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .control-label {
            font-weight: 600;
            color: #667eea;
            min-width: 150px;
        }

        .control-input {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            width: 100px;
        }

        .control-info {
            color: #666;
            font-size: 0.9em;
            flex: 1;
        }

        .frame-guide {
            margin-top: 10px;
            font-size: 0.85em;
            color: #888;
        }

        .info-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

            .info-panels.visible {
                opacity: 1;
            }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

            .panel h2 {
                color: #667eea;
                margin-bottom: 20px;
                font-size: 1.3em;
                border-bottom: 2px solid #f0f0f0;
                padding-bottom: 10px;
            }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #f5f5f5;
        }

            .info-row:last-child {
                border-bottom: none;
            }

        .info-label {
            font-weight: 600;
            color: #555;
        }

        .info-value {
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .memory-map {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
        }

        .register-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .register-item {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .register-addr {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 5px;
        }

        .register-count {
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
        }

        .register-name {
            font-size: 0.7em;
            color: #888;
            margin-top: 3px;
        }

        .zp-list {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
        }

        .zp-addresses {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .zp-address {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 600;
            color: #667eea;
        }

        .zp-summary {
            margin-bottom: 10px;
            color: #666;
            font-size: 0.9em;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

            .loading.active {
                display: block;
            }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error-message {
            background: #ff6b6b20;
            border: 1px solid #ff6b6b;
            color: #c92a2a;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }

            .error-message.visible {
                display: block;
            }

        .success-message {
            background: #51cf6620;
            border: 1px solid #51cf66;
            color: #2f9e44;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }

            .success-message.visible {
                display: block;
            }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }

            .progress-bar.active {
                display: block;
            }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }

        @media (max-width: 768px) {
            .info-panels {
                grid-template-columns: 1fr;
            }

            .register-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .zp-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ SIDwinder Web</h1>
            <p>C64 SID Music Analyzer & Tool Suite</p>
        </div>

        <div class="main-content">
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">Drop your SID file here</div>
                <div class="upload-subtext">or click to browse</div>
                <input type="file" id="fileInput" accept=".sid">
            </div>

            <div class="controls-section">
                <div class="control-group">
                    <span class="control-label">Emulation Frames:</span>
                    <input type="number" id="frameCount" class="control-input" value="3000" min="50" max="100000">
                    <span class="control-info" id="frameInfo">~1 minute at 50Hz</span>
                </div>
                <div class="frame-guide">
                    50 frames = 1 second PAL | 300 = 6 sec | 3000 = 1 min | 30000 = 10 min
                </div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Analyzing SID file...</div>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText"></div>
            </div>

            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>

            <div class="info-panels" id="infoPanels">
                <div class="panel">
                    <h2>üìÑ File Information</h2>
                    <div class="info-row">
                        <span class="info-label">Title:</span>
                        <span class="info-value" id="sidTitle">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Author:</span>
                        <span class="info-value" id="sidAuthor">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Copyright:</span>
                        <span class="info-value" id="sidCopyright">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Format:</span>
                        <span class="info-value" id="sidFormat">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Version:</span>
                        <span class="info-value" id="sidVersion">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Songs:</span>
                        <span class="info-value" id="sidSongs">-</span>
                    </div>
                </div>

                <div class="panel">
                    <h2>‚öôÔ∏è Technical Details</h2>
                    <div class="info-row">
                        <span class="info-label">Load Address:</span>
                        <span class="info-value" id="loadAddress">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Init Address:</span>
                        <span class="info-value" id="initAddress">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Play Address:</span>
                        <span class="info-value" id="playAddress">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Data Size:</span>
                        <span class="info-value" id="dataSize">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Clock:</span>
                        <span class="info-value" id="clockType">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">SID Model:</span>
                        <span class="info-value" id="sidModel">-</span>
                    </div>
                </div>

                <div class="panel">
                    <h2>üíæ Memory Analysis</h2>
                    <div id="memoryInfo">
                        <div class="info-row">
                            <span class="info-label">Code Bytes:</span>
                            <span class="info-value" id="codeBytes">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Data Bytes:</span>
                            <span class="info-value" id="dataBytes">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Zero Page Usage:</span>
                            <span class="info-value" id="zpUsage" style="font-size: 0.9em;">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Modified Memory:</span>
                            <span class="info-value" id="modifiedMemory">-</span>
                        </div>
                    </div>
                    <div class="memory-map" id="memoryMap"></div>
                </div>

                <div class="panel">
                    <h2>üéõÔ∏è SID Register Usage</h2>
                    <div class="register-grid" id="registerGrid">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="cpu6510.js"></script>
    <script>
        // SIDwinder Web Core with WASM CPU emulation
        class SIDAnalyzer {
            constructor() {
                this.memory = new Uint8Array(65536);
                this.memoryAccess = new Uint8Array(65536);
                this.sidRegisters = new Map();
                this.zpWrites = new Map();  // Track zero page writes
                this.header = null;
                this.dataSize = 0;
                this.wasmModule = null;
                this.wasmReady = false;
                this.initWASM();
            }

            async initWASM() {
                try {
                    // Initialize the WASM module
                    this.wasmModule = await CPU6510Module();

                    // Check if we need to use ccall/cwrap or direct function calls
                    const useCwrap = typeof this.wasmModule.cwrap === 'function';

                    if (useCwrap) {
                        // Use cwrap for function wrapping
                        this.cpu = {
                            init: this.wasmModule.cwrap('cpu_init', null, []),
                            loadMemory: this.wasmModule.cwrap('cpu_load_memory', null, ['number', 'number', 'number']),
                            readMemory: this.wasmModule.cwrap('cpu_read_memory', 'number', ['number']),
                            writeMemory: this.wasmModule.cwrap('cpu_write_memory', null, ['number', 'number']),
                            step: this.wasmModule.cwrap('cpu_step', null, []),
                            executeFunction: this.wasmModule.cwrap('cpu_execute_function', 'number', ['number', 'number']),
                            getPC: this.wasmModule.cwrap('cpu_get_pc', 'number', []),
                            setPC: this.wasmModule.cwrap('cpu_set_pc', null, ['number']),
                            getSP: this.wasmModule.cwrap('cpu_get_sp', 'number', []),
                            getA: this.wasmModule.cwrap('cpu_get_a', 'number', []),
                            getX: this.wasmModule.cwrap('cpu_get_x', 'number', []),
                            getY: this.wasmModule.cwrap('cpu_get_y', 'number', []),
                            getCycles: this.wasmModule.cwrap('cpu_get_cycles', 'number', []),
                            getMemoryAccess: this.wasmModule.cwrap('cpu_get_memory_access', 'number', ['number']),
                            getSidWrites: this.wasmModule.cwrap('cpu_get_sid_writes', 'number', ['number']),
                            getTotalSidWrites: this.wasmModule.cwrap('cpu_get_total_sid_writes', 'number', []),
                            getZpWrites: this.wasmModule.cwrap('cpu_get_zp_writes', 'number', ['number']),
                            getTotalZpWrites: this.wasmModule.cwrap('cpu_get_total_zp_writes', 'number', []),
                            setRecordWrites: this.wasmModule.cwrap('cpu_set_record_writes', null, ['number']),
                            analyzeMemory: this.wasmModule.cwrap('cpu_analyze_memory', null, ['number', 'number', 'number', 'number'])
                        };
                    } else {
                        // Use direct function calls with underscore prefix
                        this.cpu = {
                            init: () => this.wasmModule._cpu_init(),
                            loadMemory: (addr, ptr, size) => this.wasmModule._cpu_load_memory(addr, ptr, size),
                            readMemory: (addr) => this.wasmModule._cpu_read_memory(addr),
                            writeMemory: (addr, val) => this.wasmModule._cpu_write_memory(addr, val),
                            step: () => this.wasmModule._cpu_step(),
                            executeFunction: (addr, cycles) => this.wasmModule._cpu_execute_function(addr, cycles),
                            getPC: () => this.wasmModule._cpu_get_pc(),
                            setPC: (pc) => this.wasmModule._cpu_set_pc(pc),
                            getSP: () => this.wasmModule._cpu_get_sp(),
                            getA: () => this.wasmModule._cpu_get_a(),
                            getX: () => this.wasmModule._cpu_get_x(),
                            getY: () => this.wasmModule._cpu_get_y(),
                            getCycles: () => this.wasmModule._cpu_get_cycles(),
                            getMemoryAccess: (addr) => this.wasmModule._cpu_get_memory_access(addr),
                            getSidWrites: (reg) => this.wasmModule._cpu_get_sid_writes(reg),
                            getTotalSidWrites: () => this.wasmModule._cpu_get_total_sid_writes(),
                            getZpWrites: (addr) => this.wasmModule._cpu_get_zp_writes(addr),
                            getTotalZpWrites: () => this.wasmModule._cpu_get_total_zp_writes(),
                            setRecordWrites: (val) => this.wasmModule._cpu_set_record_writes(val),
                            analyzeMemory: (start, end, codePtr, dataPtr) => this.wasmModule._cpu_analyze_memory(start, end, codePtr, dataPtr)
                        };
                    }

                    // Initialize CPU
                    this.cpu.init();
                    this.wasmReady = true;
                    console.log('WASM CPU emulator initialized');
                } catch (error) {
                    console.warn('WASM module not available, falling back to JavaScript emulation', error);
                    this.wasmReady = false;
                }
            }

            parseSIDHeader(buffer) {
                const view = new DataView(buffer);
                const decoder = new TextDecoder('ascii');

                // Read magic ID
                const magicID = decoder.decode(new Uint8Array(buffer, 0, 4));
                if (magicID !== 'PSID' && magicID !== 'RSID') {
                    throw new Error('Invalid SID file format');
                }

                // Parse header
                this.header = {
                    magicID: magicID,
                    version: view.getUint16(4, false),
                    dataOffset: view.getUint16(6, false),
                    loadAddress: view.getUint16(8, false),
                    initAddress: view.getUint16(10, false),
                    playAddress: view.getUint16(12, false),
                    songs: view.getUint16(14, false),
                    startSong: view.getUint16(16, false),
                    speed: view.getUint32(18, false),
                    name: decoder.decode(new Uint8Array(buffer, 22, 32)).replace(/\0/g, ''),
                    author: decoder.decode(new Uint8Array(buffer, 54, 32)).replace(/\0/g, ''),
                    copyright: decoder.decode(new Uint8Array(buffer, 86, 32)).replace(/\0/g, ''),
                    flags: this.header?.version >= 2 ? view.getUint16(118, false) : 0
                };

                // Handle load address
                let dataStart = this.header.dataOffset;
                if (this.header.loadAddress === 0) {
                    // Load address is in the first two bytes of data
                    const lo = view.getUint8(dataStart);
                    const hi = view.getUint8(dataStart + 1);
                    this.header.loadAddress = lo | (hi << 8);
                    dataStart += 2;
                }

                // Load music data into memory
                this.dataSize = buffer.byteLength - dataStart;
                const musicData = new Uint8Array(buffer, dataStart, this.dataSize);
                this.loadToMemory(musicData, this.header.loadAddress);

                return this.header;
            }

            loadToMemory(data, address) {
                for (let i = 0; i < data.length; i++) {
                    if (address + i < 65536) {
                        this.memory[address + i] = data[i];
                    }
                }
            }

            async emulateInit(frameCount, progressCallback) {
                if (!this.wasmReady || !this.wasmModule) {
                    console.warn('WASM not ready, skipping emulation');
                    return { sidRegisters: new Map(), zpWrites: new Map() };
                }

                try {
                    // Reset CPU state
                    this.cpu.init();

                    // Load the SID data into WASM memory
                    const dataStart = this.header.loadAddress;
                    const musicData = this.memory.slice(dataStart, dataStart + this.dataSize);

                    console.log(`Loading ${musicData.length} bytes at ${dataStart.toString(16)}`);

                    // Load memory byte by byte using the wrapped function
                    // This is safer than trying to use HEAPU8 directly
                    for (let i = 0; i < musicData.length; i++) {
                        this.cpu.writeMemory(dataStart + i, musicData[i]);
                    }

                    // Execute init routine
                    console.log('Executing INIT at $' + this.header.initAddress.toString(16));
                    const success = this.cpu.executeFunction(this.header.initAddress, 100000);

                    if (success) {
                        console.log('INIT completed successfully');

                        // Now execute play routine multiple times to gather statistics
                        this.cpu.setRecordWrites(1);

                        const framesTotal = frameCount;
                        console.log(`Executing PLAY at $${this.header.playAddress.toString(16)} for ${framesTotal} frames...`);

                        for (let frame = 0; frame < framesTotal; frame++) {
                            this.cpu.executeFunction(this.header.playAddress, 20000);

                            // Update progress
                            if (progressCallback && frame % 10 === 0) {
                                progressCallback(frame, framesTotal);
                            }
                        }

                        // Gather SID register statistics
                        const sidRegisters = new Map();
                        for (let reg = 0; reg < 0x20; reg++) {
                            const count = this.cpu.getSidWrites(reg);
                            if (count > 0) {
                                sidRegisters.set(reg, count);
                            }
                        }

                        // Gather zero page statistics using the new tracking functions
                        const zpWrites = new Map();
                        for (let addr = 0; addr < 256; addr++) {
                            const count = this.cpu.getZpWrites ? this.cpu.getZpWrites(addr) : 0;
                            if (count > 0) {
                                zpWrites.set(addr, count);
                            }
                        }

                        // Count all modified memory (excluding zero page since we track it separately)
                        let modifiedCount = zpWrites.size;
                        for (let addr = 256; addr < 65536; addr++) {
                            const access = this.cpu.getMemoryAccess(addr);
                            if (access & 0x04) { // Write flag
                                modifiedCount++;
                            }
                        }

                        const totalZpWrites = this.cpu.getTotalZpWrites ? this.cpu.getTotalZpWrites() : zpWrites.size;
                        console.log(`Total SID writes: ${this.cpu.getTotalSidWrites()}`);
                        console.log(`Total zero page writes: ${totalZpWrites}`);
                        console.log(`Zero page locations written: ${zpWrites.size}`);
                        console.log(`Total memory locations modified: ${modifiedCount}`);

                        return {
                            sidRegisters,
                            zpWrites,
                            modifiedCount: modifiedCount + zpWrites.size
                        };
                    } else {
                        console.error('INIT routine failed or timed out');
                        return { sidRegisters: new Map(), zpWrites: new Map(), modifiedCount: 0 };
                    }
                } catch (error) {
                    console.error('Error during emulation:', error);
                    return { sidRegisters: new Map(), zpWrites: new Map(), modifiedCount: 0 };
                }
            }

            getSIDRegisterName(reg) {
                const names = {
                    0x00: 'Voice 1 Freq Lo', 0x01: 'Voice 1 Freq Hi',
                    0x02: 'Voice 1 Pulse Lo', 0x03: 'Voice 1 Pulse Hi',
                    0x04: 'Voice 1 Control', 0x05: 'Voice 1 AD',
                    0x06: 'Voice 1 SR', 0x07: 'Voice 2 Freq Lo',
                    0x08: 'Voice 2 Freq Hi', 0x09: 'Voice 2 Pulse Lo',
                    0x0A: 'Voice 2 Pulse Hi', 0x0B: 'Voice 2 Control',
                    0x0C: 'Voice 2 AD', 0x0D: 'Voice 2 SR',
                    0x0E: 'Voice 3 Freq Lo', 0x0F: 'Voice 3 Freq Hi',
                    0x10: 'Voice 3 Pulse Lo', 0x11: 'Voice 3 Pulse Hi',
                    0x12: 'Voice 3 Control', 0x13: 'Voice 3 AD',
                    0x14: 'Voice 3 SR', 0x15: 'Filter Cutoff Lo',
                    0x16: 'Filter Cutoff Hi', 0x17: 'Filter Control',
                    0x18: 'Volume & Filter', 0x19: 'Paddle X',
                    0x1A: 'Paddle Y', 0x1B: 'Voice 3 Waveform',
                    0x1C: 'Voice 3 ADSR'
                };
                return names[reg] || `Register ${reg}`;
            }

            analyzeMemory() {
                let codeBytes = 0;
                let dataBytes = 0;
                let zpUsage = 0;

                if (this.wasmReady && this.wasmModule && this.cpu && this.cpu.analyzeMemory) {
                    try {
                        // Use WASM analysis
                        const codeBytesPtr = this.wasmModule._malloc(4);
                        const dataBytesPtr = this.wasmModule._malloc(4);

                        this.cpu.analyzeMemory(
                            this.header.loadAddress,
                            this.header.loadAddress + this.dataSize - 1,
                            codeBytesPtr,
                            dataBytesPtr
                        );

                        // Use getValue if available, otherwise read directly
                        if (this.wasmModule.getValue) {
                            codeBytes = this.wasmModule.getValue(codeBytesPtr, 'i32');
                            dataBytes = this.wasmModule.getValue(dataBytesPtr, 'i32');
                        } else {
                            // Read 32-bit integers directly from memory
                            const view = new Int32Array(this.wasmModule.HEAP32.buffer, codeBytesPtr, 1);
                            codeBytes = view[0];
                            const view2 = new Int32Array(this.wasmModule.HEAP32.buffer, dataBytesPtr, 1);
                            dataBytes = view2[0];
                        }

                        this.wasmModule._free(codeBytesPtr);
                        this.wasmModule._free(dataBytesPtr);

                        // Count zero page usage from WASM memory access
                        for (let i = 0; i < 256; i++) {
                            if (this.cpu.getMemoryAccess(i) & 0x06) {  // Read or Write flags
                                zpUsage++;
                            }
                        }
                    } catch (error) {
                        console.warn('Error in WASM memory analysis, falling back:', error);
                        // Fall back to JavaScript analysis
                        return this.analyzeMemoryFallback();
                    }
                } else {
                    return this.analyzeMemoryFallback();
                }

                return {
                    codeBytes,
                    dataBytes,
                    zpUsage,
                    totalSize: this.dataSize
                };
            }

            analyzeMemoryFallback() {
                let codeBytes = 0;
                let dataBytes = 0;
                let zpUsage = 0;

                // Simple JavaScript analysis
                for (let i = 0; i < 256; i++) {
                    if (this.memory[i] !== 0) {
                        zpUsage++;
                    }
                }

                const startAddr = this.header.loadAddress;
                const endAddr = startAddr + this.dataSize;

                for (let addr = startAddr; addr < endAddr; addr++) {
                    const byte = this.memory[addr];
                    // Common 6502 opcodes
                    if ([0xA9, 0xA5, 0xAD, 0x85, 0x8D, 0x20, 0x60, 0x4C].includes(byte)) {
                        codeBytes++;
                    } else {
                        dataBytes++;
                    }
                }

                return {
                    codeBytes,
                    dataBytes,
                    zpUsage,
                    totalSize: this.dataSize
                };
            }

            getClockType() {
                if (!this.header || this.header.version < 2) return 'PAL';
                const flags = this.header.flags;
                if ((flags & 0x0C) === 0x04) return 'PAL';
                if ((flags & 0x0C) === 0x08) return 'NTSC';
                if ((flags & 0x0C) === 0x0C) return 'PAL/NTSC';
                return 'Unknown';
            }

            getSIDModel() {
                if (!this.header || this.header.version < 2) return '6581';
                const flags = this.header.flags;
                if ((flags & 0x30) === 0x10) return '6581';
                if ((flags & 0x30) === 0x20) return '8580';
                if ((flags & 0x30) === 0x30) return '6581/8580';
                return 'Unknown';
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.analyzer = new SIDAnalyzer();
                this.initEventListeners();
                this.updateFrameInfo();
            }

            initEventListeners() {
                const uploadSection = document.getElementById('uploadSection');
                const fileInput = document.getElementById('fileInput');
                const frameCountInput = document.getElementById('frameCount');

                uploadSection.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                frameCountInput.addEventListener('input', () => this.updateFrameInfo());

                // Drag and drop
                uploadSection.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadSection.classList.add('dragover');
                });

                uploadSection.addEventListener('dragleave', () => {
                    uploadSection.classList.remove('dragover');
                });

                uploadSection.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.processFile(files[0]);
                    }
                });
            }

            updateFrameInfo() {
                const frameCount = parseInt(document.getElementById('frameCount').value) || 3000;
                const seconds = frameCount / 50;  // PAL
                const minutes = seconds / 60;

                let info = '';
                if (minutes >= 1) {
                    info = `~${minutes.toFixed(1)} minute${minutes !== 1 ? 's' : ''} at 50Hz`;
                } else {
                    info = `~${seconds.toFixed(1)} second${seconds !== 1 ? 's' : ''} at 50Hz`;
                }

                document.getElementById('frameInfo').textContent = info;
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }

            async processFile(file) {
                if (!file.name.toLowerCase().endsWith('.sid')) {
                    this.showError('Please select a valid SID file');
                    return;
                }

                this.showLoading(true);
                this.hideMessages();

                try {
                    const buffer = await file.arrayBuffer();
                    const header = this.analyzer.parseSIDHeader(buffer);

                    // Wait for WASM if it's still loading
                    if (!this.analyzer.wasmReady) {
                        console.log('Waiting for WASM module...');
                        await new Promise(resolve => {
                            const checkWASM = setInterval(() => {
                                if (this.analyzer.wasmReady) {
                                    clearInterval(checkWASM);
                                    resolve();
                                }
                            }, 100);
                            // Timeout after 5 seconds
                            setTimeout(() => {
                                clearInterval(checkWASM);
                                resolve();
                            }, 5000);
                        });
                    }

                    // Show progress bar
                    const progressBar = document.getElementById('progressBar');
                    const progressFill = document.getElementById('progressFill');
                    const progressText = document.getElementById('progressText');
                    progressBar.classList.add('active');

                    // Run emulation if WASM is available
                    const frameCount = parseInt(document.getElementById('frameCount').value) || 3000;
                    const { sidRegisters, zpWrites, modifiedCount } = await this.analyzer.emulateInit(
                        frameCount,
                        (current, total) => {
                            const percent = (current / total * 100).toFixed(1);
                            progressFill.style.width = percent + '%';
                            progressText.textContent = `Frame ${current} / ${total} (${percent}%)`;
                        }
                    );

                    // Analyze memory
                    const memoryStats = this.analyzer.analyzeMemory();

                    // Update UI
                    this.updateFileInfo(header);
                    this.updateTechnicalInfo(header);
                    this.updateMemoryInfo(memoryStats, modifiedCount, zpWrites);
                    this.updateRegisterInfo(sidRegisters);

                    // Show panels
                    document.getElementById('infoPanels').classList.add('visible');

                    const emulationType = this.analyzer.wasmReady ? 'WASM emulation' : 'static analysis';
                    this.showSuccess(`Successfully analyzed: ${file.name} (using ${emulationType})`);

                } catch (error) {
                    this.showError(`Error: ${error.message}`);
                    console.error(error);
                } finally {
                    this.showLoading(false);
                    document.getElementById('progressBar').classList.remove('active');
                }
            }

            updateFileInfo(header) {
                document.getElementById('sidTitle').textContent = header.name || 'Unknown';
                document.getElementById('sidAuthor').textContent = header.author || 'Unknown';
                document.getElementById('sidCopyright').textContent = header.copyright || 'Unknown';
                document.getElementById('sidFormat').textContent = header.magicID;
                document.getElementById('sidVersion').textContent = `v${header.version}`;
                document.getElementById('sidSongs').textContent = `${header.startSong}/${header.songs}`;
            }

            updateTechnicalInfo(header) {
                document.getElementById('loadAddress').textContent = `$${header.loadAddress.toString(16).toUpperCase().padStart(4, '0')}`;
                document.getElementById('initAddress').textContent = `$${header.initAddress.toString(16).toUpperCase().padStart(4, '0')}`;
                document.getElementById('playAddress').textContent = `$${header.playAddress.toString(16).toUpperCase().padStart(4, '0')}`;
                document.getElementById('dataSize').textContent = `${this.analyzer.dataSize} bytes`;
                document.getElementById('clockType').textContent = this.analyzer.getClockType();
                document.getElementById('sidModel').textContent = this.analyzer.getSIDModel();
            }

            formatZeroPageUsage(zpWrites) {
                if (zpWrites.size === 0) {
                    return 'None';
                }

                // Get sorted list of addresses
                const addresses = Array.from(zpWrites.keys()).sort((a, b) => a - b);

                // Group consecutive addresses into ranges
                const groups = [];
                let currentGroup = { start: addresses[0], end: addresses[0] };

                for (let i = 1; i < addresses.length; i++) {
                    if (addresses[i] === currentGroup.end + 1) {
                        // Consecutive address, extend the range
                        currentGroup.end = addresses[i];
                    } else {
                        // Non-consecutive, save current group and start new one
                        groups.push(currentGroup);
                        currentGroup = { start: addresses[i], end: addresses[i] };
                    }
                }
                groups.push(currentGroup);

                // Format the groups
                const formatted = groups.map(group => {
                    if (group.start === group.end) {
                        // Single address
                        return `${group.start.toString(16).toUpperCase().padStart(2, '0')}`;
                    } else {
                        // Range of addresses
                        return `${group.start.toString(16).toUpperCase().padStart(2, '0')}-${group.end.toString(16).toUpperCase().padStart(2, '0')}`;
                    }
                });

                // If more than 8 groups, show first 7 and add ellipsis
                if (formatted.length > 8) {
                    return formatted.slice(0, 7).join(', ') + ', ...';
                }

                return formatted.join(', ');
            }

            updateMemoryInfo(stats, modifiedCount = 0, zpWrites = new Map()) {
                document.getElementById('codeBytes').textContent = `${stats.codeBytes} bytes`;
                document.getElementById('dataBytes').textContent = `${stats.dataBytes} bytes`;
                document.getElementById('zpUsage').textContent = this.formatZeroPageUsage(zpWrites);
                document.getElementById('modifiedMemory').textContent = modifiedCount ? `${modifiedCount} locations` : 'N/A';

                // Create memory map visualization
                const memoryMap = document.getElementById('memoryMap');
                const startAddr = this.analyzer.header.loadAddress;
                const endAddr = startAddr + this.analyzer.dataSize;

                memoryMap.innerHTML = `
                        <div>Memory Range: $${startAddr.toString(16).toUpperCase().padStart(4, '0')} - $${endAddr.toString(16).toUpperCase().padStart(4, '0')}</div>
                        <div>Total Size: ${stats.totalSize} bytes</div>
                        <div style="margin-top: 10px;">
                            <div style="background: linear-gradient(90deg, #667eea 0%, #667eea ${(stats.codeBytes / stats.totalSize * 100)}%, #764ba2 ${(stats.codeBytes / stats.totalSize * 100)}%, #764ba2 100%); height: 20px; border-radius: 5px;"></div>
                            <div style="margin-top: 5px; font-size: 0.8em;">
                                <span style="color: #667eea;">‚ñ† Code (${Math.round(stats.codeBytes / stats.totalSize * 100)}%)</span>
                                <span style="margin-left: 20px; color: #764ba2;">‚ñ† Data (${Math.round(stats.dataBytes / stats.totalSize * 100)}%)</span>
                            </div>
                        </div>
                    `;
            }

            updateRegisterInfo(sidRegisters) {
                const registerGrid = document.getElementById('registerGrid');
                registerGrid.innerHTML = '';

                // Show top used registers
                const sortedRegisters = Array.from(sidRegisters.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 8);

                sortedRegisters.forEach(([reg, count]) => {
                    const div = document.createElement('div');
                    div.className = 'register-item';
                    div.innerHTML = `
                            <div class="register-addr">$D4${reg.toString(16).toUpperCase().padStart(2, '0')}</div>
                            <div class="register-count">${count}</div>
                            <div class="register-name">${this.analyzer.getSIDRegisterName(reg)}</div>
                        `;
                    registerGrid.appendChild(div);
                });

                if (sortedRegisters.length === 0) {
                    registerGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999;">No SID writes detected</div>';
                }
            }

            updateZeroPageList(zpWrites) {
                const zpList = document.getElementById('zpList');
                const zpSummary = document.getElementById('zpSummary');
                const zpAddresses = document.getElementById('zpAddresses');

                if (zpWrites.size === 0) {
                    zpSummary.textContent = 'No zero page locations were modified during emulation';
                    zpAddresses.innerHTML = '';
                    return;
                }

                // Get sorted list of addresses
                const addresses = Array.from(zpWrites.keys()).sort((a, b) => a - b);

                // Create summary text
                const totalWrites = Array.from(zpWrites.values()).reduce((sum, count) => sum + count, 0);
                zpSummary.textContent = `${addresses.length} zero page location${addresses.length !== 1 ? 's' : ''} used (${totalWrites} total write${totalWrites !== 1 ? 's' : ''}):`;

                // Group consecutive addresses into ranges
                const groups = [];
                let currentGroup = { start: addresses[0], end: addresses[0], writes: [zpWrites.get(addresses[0])] };

                for (let i = 1; i < addresses.length; i++) {
                    if (addresses[i] === currentGroup.end + 1) {
                        // Consecutive address, extend the range
                        currentGroup.end = addresses[i];
                        currentGroup.writes.push(zpWrites.get(addresses[i]));
                    } else {
                        // Non-consecutive, save current group and start new one
                        groups.push(currentGroup);
                        currentGroup = { start: addresses[i], end: addresses[i], writes: [zpWrites.get(addresses[i])] };
                    }
                }
                groups.push(currentGroup);

                // Format the groups
                zpAddresses.innerHTML = '';
                groups.forEach(group => {
                    const div = document.createElement('div');
                    div.className = 'zp-address';

                    let text;
                    if (group.start === group.end) {
                        // Single address
                        text = `${group.start.toString(16).toUpperCase().padStart(2, '0')}`;
                        const writes = group.writes[0];
                        div.title = `Address ${group.start.toString(16).toUpperCase().padStart(2, '0')}: ${writes} write${writes !== 1 ? 's' : ''}`;
                    } else {
                        // Range of addresses
                        text = `${group.start.toString(16).toUpperCase().padStart(2, '0')}-${group.end.toString(16).toUpperCase().padStart(2, '0')}`;
                        const totalWrites = group.writes.reduce((sum, count) => sum + count, 0);
                        const count = group.end - group.start + 1;
                        div.title = `Addresses ${group.start.toString(16).toUpperCase().padStart(2, '0')} to ${group.end.toString(16).toUpperCase().padStart(2, '0')} (${count} locations): ${totalWrites} total writes`;
                    }

                    div.textContent = text;
                    zpAddresses.appendChild(div);
                });
            }

            showLoading(show) {
                document.getElementById('loading').classList.toggle('active', show);
            }

            showError(message) {
                const errorEl = document.getElementById('errorMessage');
                errorEl.textContent = message;
                errorEl.classList.add('visible');
            }

            showSuccess(message) {
                const successEl = document.getElementById('successMessage');
                successEl.textContent = message;
                successEl.classList.add('visible');
            }

            hideMessages() {
                document.getElementById('errorMessage').classList.remove('visible');
                document.getElementById('successMessage').classList.remove('visible');
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new UIController();
        });
    </script>
</body>
</html>