<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIDwinder Web - C64 SID Music Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

            .header h1 {
                font-size: 2.5em;
                margin-bottom: 10px;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            }

            .header p {
                font-size: 1.1em;
                opacity: 0.9;
            }

        .main-content {
            padding: 40px;
        }

        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(102, 126, 234, 0.05);
        }

            .upload-section:hover {
                border-color: #764ba2;
                background: rgba(102, 126, 234, 0.1);
                transform: translateY(-2px);
            }

            .upload-section.dragover {
                background: rgba(102, 126, 234, 0.2);
                border-color: #764ba2;
            }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .upload-text {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 10px;
        }

        .upload-subtext {
            color: #666;
            font-size: 0.9em;
        }

        #fileInput {
            display: none;
        }

        .song-title-section {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            display: none;
        }

            .song-title-section.visible {
                display: block;
            }

        .song-title {
            font-size: 1.5em;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .song-author {
            font-size: 1.1em;
            color: #764ba2;
        }

        .info-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

            .info-panels.visible {
                opacity: 1;
            }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

            .panel h2 {
                color: #667eea;
                margin-bottom: 20px;
                font-size: 1.3em;
                border-bottom: 2px solid #f0f0f0;
                padding-bottom: 10px;
            }

            .panel.full-width {
                grid-column: 1 / -1;
            }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #f5f5f5;
        }

            .info-row:last-child {
                border-bottom: none;
            }

        .info-label {
            font-weight: 600;
            color: #555;
        }

        .info-value {
            color: #333;
            font-family: 'Courier New', monospace;
        }

            .info-value.editable {
                cursor: pointer;
                padding: 2px 6px;
                border-radius: 4px;
                transition: all 0.2s;
                border: 1px dashed transparent;
                position: relative;
            }

                .info-value.editable:hover {
                    background: rgba(102, 126, 234, 0.1);
                    border: 1px dashed #667eea;
                }

        .edit-icon {
            display: inline-block;
            margin-left: 8px;
            color: #667eea;
            font-size: 0.9em;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .info-value.editable:hover .edit-icon {
            opacity: 1;
        }

        .info-value.editing {
            background: white;
            border: 2px solid #667eea;
            padding: 4px 8px;
            outline: none;
            cursor: text;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-width: 200px;
            display: inline-block;
        }

        .save-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            display: none;
            transition: transform 0.2s, box-shadow 0.2s;
        }

            .save-button.visible {
                display: inline-block;
            }

            .save-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            }

            .save-button:active {
                transform: translateY(0);
            }

        .button-container {
            text-align: center;
            margin-top: 20px;
        }



        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

            .loading.active {
                display: block;
            }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error-message {
            background: #ff6b6b20;
            border: 1px solid #ff6b6b;
            color: #c92a2a;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }

            .error-message.visible {
                display: block;
            }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }

            .progress-bar.active {
                display: block;
            }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }

        /* Modal/Popup styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

            .modal-overlay.visible {
                display: flex;
                opacity: 1;
            }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }

        .modal-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

            .modal-icon.success {
                color: #51cf66;
            }

            .modal-icon.error {
                color: #ff6b6b;
            }

        .modal-message {
            font-size: 1.2em;
            color: #333;
        }

        @media (max-width: 768px) {
            .info-panels {
                grid-template-columns: 1fr;
            }

            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }

            .frame-guide {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ SIDwinder Web</h1>
            <p>C64 SID Music Analyzer & Tool Suite</p>
        </div>

        <div class="main-content">
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">Drop your SID file here</div>
                <div class="upload-subtext">or click to browse</div>
                <input type="file" id="fileInput" accept=".sid">
            </div>

            <div class="song-title-section" id="songTitleSection">
                <div class="song-title" id="songTitle">-</div>
                <div class="song-author" id="songAuthor">-</div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Analyzing SID file...</div>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText"></div>
            </div>

            <div class="error-message" id="errorMessage"></div>

            <div class="info-panels" id="infoPanels">
                <div class="panel">
                    <h2>üìÑ File Information</h2>
                    <div class="info-row">
                        <span class="info-label">Title:</span>
                        <span class="info-value editable" id="sidTitle" contenteditable="false" title="Click to edit">-<span class="edit-icon">‚úèÔ∏è</span></span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Author:</span>
                        <span class="info-value editable" id="sidAuthor" contenteditable="false" title="Click to edit">-<span class="edit-icon">‚úèÔ∏è</span></span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Copyright:</span>
                        <span class="info-value editable" id="sidCopyright" contenteditable="false" title="Click to edit">-<span class="edit-icon">‚úèÔ∏è</span></span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Format:</span>
                        <span class="info-value" id="sidFormat">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Version:</span>
                        <span class="info-value" id="sidVersion">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Songs:</span>
                        <span class="info-value" id="sidSongs">-</span>
                    </div>
                </div>

                <div class="panel">
                    <h2>‚öôÔ∏è Technical Details</h2>
                    <div class="info-row">
                        <span class="info-label">Load Address:</span>
                        <span class="info-value" id="loadAddress">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Init Address:</span>
                        <span class="info-value" id="initAddress">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Play Address:</span>
                        <span class="info-value" id="playAddress">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Memory Range:</span>
                        <span class="info-value" id="memoryRange">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">File Size:</span>
                        <span class="info-value" id="fileSize">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Zero Page Usage:</span>
                        <span class="info-value" id="zpUsage" style="font-size: 0.9em;">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Clock:</span>
                        <span class="info-value" id="clockType">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">SID Model:</span>
                        <span class="info-value" id="sidModel">-</span>
                    </div>
                </div>
            </div>

            <div class="button-container">
                <button class="save-button" id="saveButton">üíæ Save Modified SID</button>
            </div>
        </div>


    </div>

    <!-- Modal overlay for success/error messages -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-icon" id="modalIcon">‚úì</div>
            <div class="modal-message" id="modalMessage">Success!</div>
        </div>
    </div>

    <script src="cpu6510.js"></script>
    <script>
        // SIDwinder Web Core with WASM CPU emulation
        class SIDAnalyzer {
            constructor() {
                this.memory = new Uint8Array(65536);
                this.memoryAccess = new Uint8Array(65536);
                this.sidRegisters = new Map();
                this.zpWrites = new Map();  // Track zero page writes
                this.header = null;
                this.fileSize = 0;
                this.wasmModule = null;
                this.wasmReady = false;
                this.originalBuffer = null;  // Store the original file buffer for saving
                this.initWASM();
            }

            async initWASM() {
                try {
                    // Initialize the WASM module
                    this.wasmModule = await CPU6510Module();

                    // Check if we need to use ccall/cwrap or direct function calls
                    const useCwrap = typeof this.wasmModule.cwrap === 'function';

                    if (useCwrap) {
                        // Use cwrap for function wrapping
                        this.cpu = {
                            init: this.wasmModule.cwrap('cpu_init', null, []),
                            loadMemory: this.wasmModule.cwrap('cpu_load_memory', null, ['number', 'number', 'number']),
                            readMemory: this.wasmModule.cwrap('cpu_read_memory', 'number', ['number']),
                            writeMemory: this.wasmModule.cwrap('cpu_write_memory', null, ['number', 'number']),
                            step: this.wasmModule.cwrap('cpu_step', null, []),
                            executeFunction: this.wasmModule.cwrap('cpu_execute_function', 'number', ['number', 'number']),
                            getPC: this.wasmModule.cwrap('cpu_get_pc', 'number', []),
                            setPC: this.wasmModule.cwrap('cpu_set_pc', null, ['number']),
                            getSP: this.wasmModule.cwrap('cpu_get_sp', 'number', []),
                            getA: this.wasmModule.cwrap('cpu_get_a', 'number', []),
                            getX: this.wasmModule.cwrap('cpu_get_x', 'number', []),
                            getY: this.wasmModule.cwrap('cpu_get_y', 'number', []),
                            getCycles: this.wasmModule.cwrap('cpu_get_cycles', 'number', []),
                            getMemoryAccess: this.wasmModule.cwrap('cpu_get_memory_access', 'number', ['number']),
                            getSidWrites: this.wasmModule.cwrap('cpu_get_sid_writes', 'number', ['number']),
                            getTotalSidWrites: this.wasmModule.cwrap('cpu_get_total_sid_writes', 'number', []),
                            getZpWrites: this.wasmModule.cwrap('cpu_get_zp_writes', 'number', ['number']),
                            getTotalZpWrites: this.wasmModule.cwrap('cpu_get_total_zp_writes', 'number', []),
                            setRecordWrites: this.wasmModule.cwrap('cpu_set_record_writes', null, ['number']),
                            analyzeMemory: this.wasmModule.cwrap('cpu_analyze_memory', null, ['number', 'number', 'number', 'number'])
                        };
                    } else {
                        // Use direct function calls with underscore prefix
                        this.cpu = {
                            init: () => this.wasmModule._cpu_init(),
                            loadMemory: (addr, ptr, size) => this.wasmModule._cpu_load_memory(addr, ptr, size),
                            readMemory: (addr) => this.wasmModule._cpu_read_memory(addr),
                            writeMemory: (addr, val) => this.wasmModule._cpu_write_memory(addr, val),
                            step: () => this.wasmModule._cpu_step(),
                            executeFunction: (addr, cycles) => this.wasmModule._cpu_execute_function(addr, cycles),
                            getPC: () => this.wasmModule._cpu_get_pc(),
                            setPC: (pc) => this.wasmModule._cpu_set_pc(pc),
                            getSP: () => this.wasmModule._cpu_get_sp(),
                            getA: () => this.wasmModule._cpu_get_a(),
                            getX: () => this.wasmModule._cpu_get_x(),
                            getY: () => this.wasmModule._cpu_get_y(),
                            getCycles: () => this.wasmModule._cpu_get_cycles(),
                            getMemoryAccess: (addr) => this.wasmModule._cpu_get_memory_access(addr),
                            getSidWrites: (reg) => this.wasmModule._cpu_get_sid_writes(reg),
                            getTotalSidWrites: () => this.wasmModule._cpu_get_total_sid_writes(),
                            getZpWrites: (addr) => this.wasmModule._cpu_get_zp_writes(addr),
                            getTotalZpWrites: () => this.wasmModule._cpu_get_total_zp_writes(),
                            setRecordWrites: (val) => this.wasmModule._cpu_set_record_writes(val),
                            analyzeMemory: (start, end, codePtr, dataPtr) => this.wasmModule._cpu_analyze_memory(start, end, codePtr, dataPtr)
                        };
                    }

                    // Initialize CPU
                    this.cpu.init();
                    this.wasmReady = true;
                } catch (error) {
                    console.warn('WASM module not available, falling back to JavaScript emulation', error);
                    this.wasmReady = false;
                }
            }

            parseSIDHeader(buffer) {
                // Store the original buffer for later saving
                this.originalBuffer = new Uint8Array(buffer);

                const view = new DataView(buffer);
                const decoder = new TextDecoder('ascii');

                // Read magic ID
                const magicID = decoder.decode(new Uint8Array(buffer, 0, 4));
                if (magicID !== 'PSID' && magicID !== 'RSID') {
                    throw new Error('Invalid SID file format');
                }

                // Parse header
                this.header = {
                    magicID: magicID,
                    version: view.getUint16(4, false),
                    dataOffset: view.getUint16(6, false),
                    loadAddress: view.getUint16(8, false),
                    initAddress: view.getUint16(10, false),
                    playAddress: view.getUint16(12, false),
                    songs: view.getUint16(14, false),
                    startSong: view.getUint16(16, false),
                    speed: view.getUint32(18, false),
                    name: decoder.decode(new Uint8Array(buffer, 22, 32)).replace(/\0/g, ''),
                    author: decoder.decode(new Uint8Array(buffer, 54, 32)).replace(/\0/g, ''),
                    copyright: decoder.decode(new Uint8Array(buffer, 86, 32)).replace(/\0/g, ''),
                    flags: this.header?.version >= 2 ? view.getUint16(118, false) : 0
                };

                // Handle load address
                let dataStart = this.header.dataOffset;
                if (this.header.loadAddress === 0) {
                    // Load address is in the first two bytes of data
                    const lo = view.getUint8(dataStart);
                    const hi = view.getUint8(dataStart + 1);
                    this.header.loadAddress = lo | (hi << 8);
                    dataStart += 2;
                }

                // Load music data into memory
                this.fileSize = buffer.byteLength - dataStart;
                const musicData = new Uint8Array(buffer, dataStart, this.fileSize);
                this.loadToMemory(musicData, this.header.loadAddress);

                return this.header;
            }

            loadToMemory(data, address) {
                for (let i = 0; i < data.length; i++) {
                    if (address + i < 65536) {
                        this.memory[address + i] = data[i];
                    }
                }
            }

            async emulateInit(frameCount, progressCallback) {
                if (!this.wasmReady || !this.wasmModule) {
                    console.warn('WASM not ready, skipping emulation');
                    return { sidRegisters: new Map(), zpWrites: new Map() };
                }

                try {
                    // Reset CPU state
                    this.cpu.init();

                    // Load the SID data into WASM memory
                    const dataStart = this.header.loadAddress;
                    const musicData = this.memory.slice(dataStart, dataStart + this.fileSize);

                    // Load memory byte by byte using the wrapped function
                    // This is safer than trying to use HEAPU8 directly
                    for (let i = 0; i < musicData.length; i++) {
                        this.cpu.writeMemory(dataStart + i, musicData[i]);
                    }

                    // Execute init routine
                    const success = this.cpu.executeFunction(this.header.initAddress, 100000);

                    if (success) {
                        // Now execute play routine multiple times to gather statistics
                        this.cpu.setRecordWrites(1);

                        const framesTotal = frameCount;

                        for (let frame = 0; frame < framesTotal; frame++) {
                            this.cpu.executeFunction(this.header.playAddress, 20000);

                            // Update progress
                            if (progressCallback && frame % 10 === 0) {
                                progressCallback(frame, framesTotal);
                            }
                        }

                        // Gather SID register statistics
                        const sidRegisters = new Map();
                        for (let reg = 0; reg < 0x20; reg++) {
                            const count = this.cpu.getSidWrites(reg);
                            if (count > 0) {
                                sidRegisters.set(reg, count);
                            }
                        }

                        // Gather zero page statistics using the new tracking functions
                        const zpWrites = new Map();
                        for (let addr = 0; addr < 256; addr++) {
                            const count = this.cpu.getZpWrites ? this.cpu.getZpWrites(addr) : 0;
                            if (count > 0) {
                                zpWrites.set(addr, count);
                            }
                        }

                        // Count all modified memory (excluding zero page since we track it separately)
                        let modifiedCount = zpWrites.size;
                        for (let addr = 256; addr < 65536; addr++) {
                            const access = this.cpu.getMemoryAccess(addr);
                            if (access & 0x04) { // Write flag
                                modifiedCount++;
                            }
                        }

                        const totalZpWrites = this.cpu.getTotalZpWrites ? this.cpu.getTotalZpWrites() : zpWrites.size;

                        return {
                            sidRegisters,
                            zpWrites,
                            modifiedCount: modifiedCount + zpWrites.size
                        };
                    } else {
                        console.error('INIT routine failed or timed out');
                        return { sidRegisters: new Map(), zpWrites: new Map(), modifiedCount: 0 };
                    }
                } catch (error) {
                    console.error('Error during emulation:', error);
                    return { sidRegisters: new Map(), zpWrites: new Map(), modifiedCount: 0 };
                }
            }

            analyzeMemory() {
                let codeBytes = 0;
                let dataBytes = 0;
                let zpUsage = 0;

                if (this.wasmReady && this.wasmModule && this.cpu && this.cpu.analyzeMemory) {
                    try {
                        // Use WASM analysis
                        const codeBytesPtr = this.wasmModule._malloc(4);
                        const dataBytesPtr = this.wasmModule._malloc(4);

                        this.cpu.analyzeMemory(
                            this.header.loadAddress,
                            this.header.loadAddress + this.fileSize - 1,
                            codeBytesPtr,
                            dataBytesPtr
                        );

                        // Use getValue if available, otherwise read directly
                        if (this.wasmModule.getValue) {
                            codeBytes = this.wasmModule.getValue(codeBytesPtr, 'i32');
                            dataBytes = this.wasmModule.getValue(dataBytesPtr, 'i32');
                        } else {
                            // Read 32-bit integers directly from memory
                            const view = new Int32Array(this.wasmModule.HEAP32.buffer, codeBytesPtr, 1);
                            codeBytes = view[0];
                            const view2 = new Int32Array(this.wasmModule.HEAP32.buffer, dataBytesPtr, 1);
                            dataBytes = view2[0];
                        }

                        this.wasmModule._free(codeBytesPtr);
                        this.wasmModule._free(dataBytesPtr);

                        // Count zero page usage from WASM memory access
                        for (let i = 0; i < 256; i++) {
                            if (this.cpu.getMemoryAccess(i) & 0x06) {  // Read or Write flags
                                zpUsage++;
                            }
                        }
                    } catch (error) {
                        console.warn('Error in WASM memory analysis, falling back:', error);
                        // Fall back to JavaScript analysis
                        return this.analyzeMemoryFallback();
                    }
                } else {
                    return this.analyzeMemoryFallback();
                }

                return {
                    codeBytes,
                    dataBytes,
                    zpUsage,
                    totalSize: this.fileSize
                };
            }

            analyzeMemoryFallback() {
                let codeBytes = 0;
                let dataBytes = 0;
                let zpUsage = 0;

                // Simple JavaScript analysis
                for (let i = 0; i < 256; i++) {
                    if (this.memory[i] !== 0) {
                        zpUsage++;
                    }
                }

                const startAddr = this.header.loadAddress;
                const endAddr = startAddr + this.fileSize;

                for (let addr = startAddr; addr < endAddr; addr++) {
                    const byte = this.memory[addr];
                    // Common 6502 opcodes
                    if ([0xA9, 0xA5, 0xAD, 0x85, 0x8D, 0x20, 0x60, 0x4C].includes(byte)) {
                        codeBytes++;
                    } else {
                        dataBytes++;
                    }
                }

                return {
                    codeBytes,
                    dataBytes,
                    zpUsage,
                    totalSize: this.fileSize
                };
            }

            getClockType() {
                if (!this.header || this.header.version < 2) return 'PAL';
                const flags = this.header.flags;
                if ((flags & 0x0C) === 0x04) return 'PAL';
                if ((flags & 0x0C) === 0x08) return 'NTSC';
                if ((flags & 0x0C) === 0x0C) return 'PAL/NTSC';
                return 'Unknown';
            }

            // Create a modified SID file with updated metadata
            createModifiedSID(newTitle, newAuthor, newCopyright) {
                if (!this.originalBuffer) return null;

                // Clone the original buffer
                const modifiedBuffer = new Uint8Array(this.originalBuffer);

                // Encode the new strings (max 32 bytes each, null-terminated)
                const encoder = new TextEncoder();

                // Update title (offset 22, 32 bytes)
                const titleBytes = encoder.encode(newTitle.substring(0, 31));
                for (let i = 0; i < 32; i++) {
                    modifiedBuffer[22 + i] = i < titleBytes.length ? titleBytes[i] : 0;
                }

                // Update author (offset 54, 32 bytes)
                const authorBytes = encoder.encode(newAuthor.substring(0, 31));
                for (let i = 0; i < 32; i++) {
                    modifiedBuffer[54 + i] = i < authorBytes.length ? authorBytes[i] : 0;
                }

                // Update copyright (offset 86, 32 bytes)
                const copyrightBytes = encoder.encode(newCopyright.substring(0, 31));
                for (let i = 0; i < 32; i++) {
                    modifiedBuffer[86 + i] = i < copyrightBytes.length ? copyrightBytes[i] : 0;
                }

                return modifiedBuffer;
            }

            getSIDModel() {
                if (!this.header || this.header.version < 2) return '6581';
                const flags = this.header.flags;
                if ((flags & 0x30) === 0x10) return '6581';
                if ((flags & 0x30) === 0x20) return '8580';
                if ((flags & 0x30) === 0x30) return '6581/8580';
                return 'Unknown';
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.analyzer = new SIDAnalyzer();
                this.currentFileName = null;
                this.hasModifications = false;
                this.initEventListeners();
            }

            initEventListeners() {
                const uploadSection = document.getElementById('uploadSection');
                const fileInput = document.getElementById('fileInput');
                const saveButton = document.getElementById('saveButton');

                uploadSection.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                saveButton.addEventListener('click', () => this.saveSID());

                // Make editable fields work
                this.setupEditableFields();

                // Drag and drop
                uploadSection.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadSection.classList.add('dragover');
                });

                uploadSection.addEventListener('dragleave', () => {
                    uploadSection.classList.remove('dragover');
                });

                uploadSection.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.processFile(files[0]);
                    }
                });
            }

            setupEditableFields() {
                const editableFields = ['sidTitle', 'sidAuthor', 'sidCopyright'];

                editableFields.forEach(fieldId => {
                    const field = document.getElementById(fieldId);

                    // Click to edit
                    field.addEventListener('click', () => {
                        if (!field.classList.contains('editing')) {
                            this.startEditing(field);
                        }
                    });

                    // Handle Enter key to save
                    field.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.stopEditing(field);
                        }
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            this.cancelEditing(field);
                        }
                    });

                    // Handle blur (clicking outside)
                    field.addEventListener('blur', () => {
                        if (field.classList.contains('editing')) {
                            this.stopEditing(field);
                        }
                    });

                    // Track changes
                    field.addEventListener('input', () => {
                        this.hasModifications = true;
                        document.getElementById('saveButton').classList.add('visible');
                    });
                });
            }

            startEditing(field) {
                field.classList.add('editing');
                field.contentEditable = 'true';
                // Store original value without the icon
                const textOnly = field.textContent.replace('‚úèÔ∏è', '').trim();
                field.dataset.originalValue = textOnly;

                // Remove the edit icon while editing
                field.textContent = textOnly;

                // Select all text
                const range = document.createRange();
                range.selectNodeContents(field);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }

            stopEditing(field) {
                field.classList.remove('editing');
                field.contentEditable = 'false';

                // Get the text without any icons
                let text = field.textContent.replace('‚úèÔ∏è', '').trim();

                // Limit length to 31 characters (SID format limitation)
                if (text.length > 31) {
                    text = text.substring(0, 31);
                }

                // Add the edit icon back
                field.innerHTML = `${text}<span class="edit-icon">‚úèÔ∏è</span>`;
            }

            cancelEditing(field) {
                const originalValue = field.dataset.originalValue || field.textContent.replace('‚úèÔ∏è', '').trim();
                field.innerHTML = `${originalValue}<span class="edit-icon">‚úèÔ∏è</span>`;
                field.classList.remove('editing');
                field.contentEditable = 'false';
            }

            saveSID() {
                if (!this.analyzer.originalBuffer) {
                    this.showModal('No SID file loaded', false);
                    return;
                }

                // Get text content without the edit icons
                const newTitle = document.getElementById('sidTitle').textContent.replace('‚úèÔ∏è', '').trim();
                const newAuthor = document.getElementById('sidAuthor').textContent.replace('‚úèÔ∏è', '').trim();
                const newCopyright = document.getElementById('sidCopyright').textContent.replace('‚úèÔ∏è', '').trim();

                const modifiedBuffer = this.analyzer.createModifiedSID(newTitle, newAuthor, newCopyright);

                if (modifiedBuffer) {
                    // Create a blob and download it
                    const blob = new Blob([modifiedBuffer], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');

                    // Generate filename
                    const baseName = this.currentFileName ?
                        this.currentFileName.replace('.sid', '') : 'modified';
                    a.href = url;
                    a.download = `${baseName}_edited.sid`;

                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    this.showModal('SID file saved successfully!', true);
                    this.hasModifications = false;
                } else {
                    this.showModal('Failed to save SID file', false);
                }
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }

            async processFile(file) {
                if (!file.name.toLowerCase().endsWith('.sid')) {
                    this.showModal('Please select a valid SID file', false);
                    return;
                }

                this.currentFileName = file.name;
                this.hasModifications = false;
                document.getElementById('saveButton').classList.remove('visible');

                this.showLoading(true);
                this.hideMessages();

                try {
                    const buffer = await file.arrayBuffer();
                    const header = this.analyzer.parseSIDHeader(buffer);

                    // Wait for WASM if it's still loading
                    if (!this.analyzer.wasmReady) {
                        await new Promise(resolve => {
                            const checkWASM = setInterval(() => {
                                if (this.analyzer.wasmReady) {
                                    clearInterval(checkWASM);
                                    resolve();
                                }
                            }, 100);
                            // Timeout after 5 seconds
                            setTimeout(() => {
                                clearInterval(checkWASM);
                                resolve();
                            }, 5000);
                        });
                    }

                    // Show progress bar
                    const progressBar = document.getElementById('progressBar');
                    const progressFill = document.getElementById('progressFill');
                    const progressText = document.getElementById('progressText');
                    progressBar.classList.add('active');

                    // Run emulation if WASM is available
                    const frameCount = 30000;  // Fixed at 30,000 frames (10 minutes)
                    const { sidRegisters, zpWrites, modifiedCount } = await this.analyzer.emulateInit(
                        frameCount,
                        (current, total) => {
                            const percent = (current / total * 100).toFixed(1);
                            progressFill.style.width = percent + '%';
                            progressText.textContent = `Frame ${current} / ${total} (${percent}%)`;
                        }
                    );

                    // Analyze memory
                    const memoryStats = this.analyzer.analyzeMemory();

                    // Update UI
                    this.updateFileInfo(header);
                    this.updateTechnicalInfo(header, memoryStats);
                    this.updateZeroPageInfo(zpWrites);
                    this.updateSongTitle(header);

                    // Show panels
                    document.getElementById('infoPanels').classList.add('visible');
                    document.getElementById('songTitleSection').classList.add('visible');

                    // Show success modal
                    this.showModal(`Successfully analyzed: ${file.name}`, true);

                } catch (error) {
                    this.showModal(`Error: ${error.message}`, false);
                    console.error(error);
                } finally {
                    this.showLoading(false);
                    document.getElementById('progressBar').classList.remove('active');
                }
            }

            updateSongTitle(header) {
                const title = header.name || 'Unknown Title';
                const author = header.author || 'Unknown Author';

                document.getElementById('songTitle').textContent = title;
                document.getElementById('songAuthor').textContent = author;
            }

            updateFileInfo(header) {
                // Update the text content without removing the edit icons
                const updateFieldWithIcon = (id, text) => {
                    const field = document.getElementById(id);
                    if (field.classList.contains('editable')) {
                        field.innerHTML = `${text}<span class="edit-icon">‚úèÔ∏è</span>`;
                    } else {
                        field.textContent = text;
                    }
                };

                updateFieldWithIcon('sidTitle', header.name || 'Unknown');
                updateFieldWithIcon('sidAuthor', header.author || 'Unknown');
                updateFieldWithIcon('sidCopyright', header.copyright || 'Unknown');

                document.getElementById('sidFormat').textContent = header.magicID;
                document.getElementById('sidVersion').textContent = `v${header.version}`;
                document.getElementById('sidSongs').textContent = `${header.startSong}/${header.songs}`;
            }

            updateTechnicalInfo(header, memoryStats) {
                const startAddr = header.loadAddress;
                const endAddr = startAddr + this.analyzer.fileSize - 1;

                // Format addresses with $ prefix
                document.getElementById('loadAddress').textContent = `$${header.loadAddress.toString(16).toUpperCase().padStart(4, '0')}`;
                document.getElementById('initAddress').textContent = `$${header.initAddress.toString(16).toUpperCase().padStart(4, '0')}`;
                document.getElementById('playAddress').textContent = `$${header.playAddress.toString(16).toUpperCase().padStart(4, '0')}`;
                document.getElementById('memoryRange').textContent = `$${startAddr.toString(16).toUpperCase().padStart(4, '0')} - $${endAddr.toString(16).toUpperCase().padStart(4, '0')}`;

                // File size - simplified without code/data breakdown
                document.getElementById('fileSize').textContent = `${this.analyzer.fileSize} bytes`;

                document.getElementById('clockType').textContent = this.analyzer.getClockType();
                document.getElementById('sidModel').textContent = this.analyzer.getSIDModel();
            }

            updateZeroPageInfo(zpWrites) {
                document.getElementById('zpUsage').textContent = this.formatZeroPageUsage(zpWrites);
            }

            formatZeroPageUsage(zpWrites) {
                if (zpWrites.size === 0) {
                    return 'None';
                }

                // Get sorted list of addresses
                const addresses = Array.from(zpWrites.keys()).sort((a, b) => a - b);

                // Group consecutive addresses into ranges
                const groups = [];
                let currentGroup = { start: addresses[0], end: addresses[0] };

                for (let i = 1; i < addresses.length; i++) {
                    if (addresses[i] === currentGroup.end + 1) {
                        // Consecutive address, extend the range
                        currentGroup.end = addresses[i];
                    } else {
                        // Non-consecutive, save current group and start new one
                        groups.push(currentGroup);
                        currentGroup = { start: addresses[i], end: addresses[i] };
                    }
                }
                groups.push(currentGroup);

                // Format the groups with $ prefix for hex values
                const formatted = groups.map(group => {
                    if (group.start === group.end) {
                        // Single address
                        return `$${group.start.toString(16).toUpperCase().padStart(2, '0')}`;
                    } else {
                        // Range of addresses
                        return `$${group.start.toString(16).toUpperCase().padStart(2, '0')}-$${group.end.toString(16).toUpperCase().padStart(2, '0')}`;
                    }
                });

                // Join all groups and check total length
                const result = formatted.join(', ');

                // If the string is too long, truncate it intelligently
                if (result.length > 100) {  // Arbitrary length limit
                    // Take as many complete entries as fit in ~90 chars
                    let truncated = '';
                    for (let i = 0; i < formatted.length; i++) {
                        const nextPart = (i === 0 ? '' : ', ') + formatted[i];
                        if (truncated.length + nextPart.length > 90) {
                            return truncated + ', ...';
                        }
                        truncated += nextPart;
                    }
                    return truncated + ', ...';
                }

                return result;
            }

            showLoading(show) {
                document.getElementById('loading').classList.toggle('active', show);
            }

            showError(message) {
                const errorEl = document.getElementById('errorMessage');
                errorEl.textContent = message;
                errorEl.classList.add('visible');
            }

            showModal(message, isSuccess) {
                const overlay = document.getElementById('modalOverlay');
                const icon = document.getElementById('modalIcon');
                const messageEl = document.getElementById('modalMessage');

                // Set content
                icon.textContent = isSuccess ? '‚úì' : '‚úó';
                icon.className = isSuccess ? 'modal-icon success' : 'modal-icon error';
                messageEl.textContent = message;

                // Show modal
                overlay.classList.add('visible');

                // Auto-hide after 2 seconds
                setTimeout(() => {
                    overlay.classList.remove('visible');
                }, 2000);
            }

            hideMessages() {
                document.getElementById('errorMessage').classList.remove('visible');
                document.getElementById('songTitleSection').classList.remove('visible');
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new UIController();
        });
    </script>
</body>
</html>