// bar-styles-data.js - Bar Style Character Data for SIDwinder Web
// This module contains the character bitmap data for all bar styles,
// allowing the web app to inject the selected style directly into the charset.
//
// SIMPLIFIED DATA FORMAT:
// - Only main bar chars are stored (10 chars Ã— 8 bytes = 80 bytes per style)
// - Mirror chars are computed by reversing byte order
// - Reflection frames are computed by applying alternating 0x55/0xAA masks

// Constants
const BAR_STYLE_SIZE_WATER = 240;  // 30 chars * 8 bytes (10 main + 10 ref1 + 10 ref2)
const BAR_STYLE_SIZE_MIRROR = 160; // 20 chars * 8 bytes (10 main + 10 mirrored)
const NUM_BAR_STYLES = 8;
const CHARS_PER_STYLE = 10;
const BYTES_PER_CHAR = 8;

// Main Bar Styles - only the primary bar characters
// Each style has 10 chars representing bar heights from empty to full
const BAR_STYLES_MAIN = [
    // Style 0: CLASSIC (rounded with highlights)
    new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // Empty
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C,     // 1/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xBE,     // 2/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xBE, 0xBE,     // 3/8
        0x00, 0x00, 0x00, 0x00, 0x7C, 0x14, 0xBE, 0xBE,     // 4/8
        0x00, 0x00, 0x00, 0x7C, 0xBE, 0x14, 0xBE, 0xBE,     // 5/8
        0x00, 0x00, 0x7C, 0xBE, 0xBE, 0x14, 0xBE, 0xBE,     // 6/8
        0x00, 0x7C, 0xBE, 0xBE, 0xBE, 0x14, 0xBE, 0xBE,     // 7/8
        0x7C, 0x14, 0xBE, 0xBE, 0xBE, 0x14, 0xBE, 0xBE,     // 8/8
        0xBE, 0x14, 0xBE, 0xBE, 0xBE, 0x14, 0xBE, 0xBE      // Full
    ]),

    // Style 1: SOLID (full solid bars)
    new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // Empty
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E,     // 1/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E,     // 2/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E,     // 3/8
        0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x7E,     // 4/8
        0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E,     // 5/8
        0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E,     // 6/8
        0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E,     // 7/8
        0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E,     // 8/8
        0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E      // Full
    ]),

    // Style 2: THIN (narrow 4-pixel bars)
    new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // Empty
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C,     // 1/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C,     // 2/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C,     // 3/8
        0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C,     // 4/8
        0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,     // 5/8
        0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,     // 6/8
        0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,     // 7/8
        0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,     // 8/8
        0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C      // Full
    ]),

    // Style 3: OUTLINE (hollow bars)
    new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // Empty
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E,     // 1/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x42,     // 2/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x42, 0x42,     // 3/8
        0x00, 0x00, 0x00, 0x00, 0x7E, 0x42, 0x42, 0x42,     // 4/8
        0x00, 0x00, 0x00, 0x7E, 0x42, 0x42, 0x42, 0x42,     // 5/8
        0x00, 0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42,     // 6/8
        0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,     // 7/8
        0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,     // 8/8
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42      // Full (just sides)
    ]),

    // Style 4: CHUNKY (blocky pixel bars)
    new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // Empty
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66,     // 1/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66,     // 2/8
        0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,     // 3/8
        0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,     // 4/8
        0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,     // 5/8
        0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,     // 6/8
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,     // 7/8
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,     // 8/8
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66      // Full
    ]),

    // Style 5: SMOOTH (RaistlinMirrorBars style - no highlight)
    new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // Empty
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C,     // 1/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xBE,     // 2/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xBE, 0xBE,     // 3/8
        0x00, 0x00, 0x00, 0x00, 0x7C, 0xBE, 0xBE, 0xBE,     // 4/8
        0x00, 0x00, 0x00, 0x7C, 0xBE, 0xBE, 0xBE, 0xBE,     // 5/8
        0x00, 0x00, 0x7C, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE,     // 6/8
        0x00, 0x7C, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE,     // 7/8
        0x7C, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE,     // 8/8
        0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE      // Full
    ]),

    // Style 6: POINTED (pointed top)
    new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // Empty
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,     // 1/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C,     // 2/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E,     // 3/8
        0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0x7E,     // 4/8
        0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0x7E, 0x7E,     // 5/8
        0x00, 0x00, 0x18, 0x3C, 0x7E, 0x7E, 0x7E, 0x7E,     // 6/8
        0x00, 0x18, 0x3C, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E,     // 7/8
        0x18, 0x3C, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E,     // 8/8
        0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E      // Full
    ]),

    // Style 7: LINED (solid with scanlines)
    new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // Empty
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E,     // 1/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E,     // 2/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E,     // 3/8
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E,     // 4/8
        0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E,     // 5/8
        0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E,     // 6/8
        0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E,     // 7/8
        0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E,     // 8/8
        0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E      // Full
    ])
];

// Helper: Get mirrored bytes for a single char (reverse byte order)
function getMirroredChar(mainData, charIndex) {
    const offset = charIndex * BYTES_PER_CHAR;
    const result = new Uint8Array(BYTES_PER_CHAR);
    for (let i = 0; i < BYTES_PER_CHAR; i++) {
        result[i] = mainData[offset + (BYTES_PER_CHAR - 1 - i)];
    }
    return result;
}

// Generate water reflection data (main + ref1 + ref2)
// Reflection uses alternating 0x55/0xAA scanline flicker effect on mirrored chars
function generateWaterData(styleIndex) {
    const main = BAR_STYLES_MAIN[styleIndex];
    const result = new Uint8Array(BAR_STYLE_SIZE_WATER);

    // Copy main chars (10 chars = 80 bytes)
    result.set(main, 0);

    // Generate reflection frames from mirrored chars
    for (let c = 0; c < CHARS_PER_STYLE; c++) {
        const mirror = getMirroredChar(main, c);
        const baseOffset1 = 80 + c * BYTES_PER_CHAR;  // Reflection frame 1
        const baseOffset2 = 160 + c * BYTES_PER_CHAR; // Reflection frame 2

        for (let b = 0; b < BYTES_PER_CHAR; b++) {
            // Frame 1: even rows use 0xAA mask, odd rows use 0x55 mask
            result[baseOffset1 + b] = mirror[b] & ((b % 2 === 0) ? 0xAA : 0x55);
            // Frame 2: even rows use 0x55 mask, odd rows use 0xAA mask
            result[baseOffset2 + b] = mirror[b] & ((b % 2 === 0) ? 0x55 : 0xAA);
        }
    }

    return result;
}

// Generate mirror data (main + mirrored)
function generateMirrorData(styleIndex) {
    const main = BAR_STYLES_MAIN[styleIndex];
    const result = new Uint8Array(BAR_STYLE_SIZE_MIRROR);

    // Copy main chars (10 chars = 80 bytes)
    result.set(main, 0);

    // Generate mirrored chars (10 chars = 80 bytes)
    for (let c = 0; c < CHARS_PER_STYLE; c++) {
        const mirror = getMirroredChar(main, c);
        result.set(mirror, 80 + c * BYTES_PER_CHAR);
    }

    return result;
}

// Cache for generated data (avoid recomputing each time)
const waterDataCache = new Array(NUM_BAR_STYLES).fill(null);
const mirrorDataCache = new Array(NUM_BAR_STYLES).fill(null);

// Helper function to get bar style data
function getBarStyleData(styleType, styleIndex) {
    if (styleIndex < 0 || styleIndex >= NUM_BAR_STYLES) {
        styleIndex = 0; // Default to style 0 if invalid
    }

    if (styleType === 'water') {
        if (!waterDataCache[styleIndex]) {
            waterDataCache[styleIndex] = generateWaterData(styleIndex);
        }
        return waterDataCache[styleIndex];
    } else if (styleType === 'mirror') {
        if (!mirrorDataCache[styleIndex]) {
            mirrorDataCache[styleIndex] = generateMirrorData(styleIndex);
        }
        return mirrorDataCache[styleIndex];
    }

    return null;
}

// Export for use in other modules
window.BAR_STYLES_DATA = {
    main: BAR_STYLES_MAIN,
    getBarStyleData: getBarStyleData,
    BAR_STYLE_SIZE_WATER: BAR_STYLE_SIZE_WATER,
    BAR_STYLE_SIZE_MIRROR: BAR_STYLE_SIZE_MIRROR,
    NUM_BAR_STYLES: NUM_BAR_STYLES
};
